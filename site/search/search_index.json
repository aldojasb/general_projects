{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"guides/","title":"Welcome to My Software &amp; Data Science Portfolio","text":"<p>This portfolio showcases my expertise in software architecture, unit testing, deep learning, and applied projects. The goal is to document best practices, key principles, and hands-on experience in designing scalable, maintainable, and efficient software systems.</p>"},{"location":"guides/#what-youll-find-here","title":"\ud83d\udccc What You'll Find Here","text":"<ul> <li>Software Architecture: Principles and patterns that enable flexible, scalable, and maintainable systems, including SOLID principles and Clean Architecture concepts.</li> <li>Unit Testing: Best practices using pytest, covering effective test structures, mocking, and CI/CD integration.</li> <li>Deep Learning: Learning projects related to autoencoders and reinforcement learning, demonstrating key techniques and applications.</li> <li>Projects: A showcase of real-world applications and hands-on implementations that reinforce these concepts.</li> </ul>"},{"location":"guides/#purpose-of-this-portfolio","title":"\ud83c\udfaf Purpose of This Portfolio","text":"<p>This collection of guides and projects serves as a learning resource and a technical showcase for recruiters, employers, and fellow developers. Whether you're exploring software design patterns, refining your testing skills, or diving into AI/ML topics, you\u2019ll find structured content here.</p>"},{"location":"guides/#how-to-navigate","title":"\ud83d\udd0d How to Navigate","text":"<p>Use the navigation menu to explore each section. Each guide is structured with:</p> <ul> <li>Overview: A high-level explanation of the topic.</li> <li>Concepts: Core ideas and principles.</li> <li>(Optional) Best Practices &amp; Code Examples: Real-world implementations and insights.</li> </ul> <p>Feel free to reach out for discussions or collaborations! \ud83d\ude80</p>"},{"location":"guides/deep_learning/overview/","title":"Overview","text":""},{"location":"guides/deep_learning/overview/#tbd","title":"TBD","text":""},{"location":"guides/projects/overview/","title":"Overview","text":""},{"location":"guides/projects/overview/#tbd","title":"TBD","text":""},{"location":"guides/software_architecture/SOLID_principles/","title":"SOLID Principles","text":""},{"location":"guides/software_architecture/SOLID_principles/#solid-principles","title":"SOLID Principles","text":"<p>The SOLID principles are foundational for creating maintainable and scalable software. These principles guide developers in designing mid-level software structures that:</p> <ul> <li>Tolerate change</li> <li>Are easy to understand</li> <li>Serve as reusable components in various software systems</li> </ul>"},{"location":"guides/software_architecture/SOLID_principles/#single-responsibility-principle-srp","title":"Single Responsibility Principle (SRP)","text":"<p>Definition: A class should have only one reason to change, meaning it should only have one job or responsibility.</p>"},{"location":"guides/software_architecture/SOLID_principles/#example","title":"Example","text":"<pre><code># Bad example\nclass ReportManager:\n    def generate_report(self):\n        # logic for generating report\n        pass\n\n    def save_to_file(self):\n        # logic for saving report to file\n        pass\n\n# Good example (separating responsibilities)\nclass ReportGenerator:\n    def generate_report(self):\n        # logic for generating report\n        pass\n\nclass ReportSaver:\n    def save_to_file(self, report):\n        # logic for saving report to file\n        pass\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#key-takeaway","title":"Key Takeaway","text":"<p>A module should be responsible to one and only one actor. This ensures clarity, maintainability, and flexibility.</p>"},{"location":"guides/software_architecture/SOLID_principles/#open-closed-principle-ocp","title":"Open-Closed Principle (OCP)","text":"<p>Definition: Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.</p>"},{"location":"guides/software_architecture/SOLID_principles/#counter-example-violation-of-ocp","title":"Counter-Example (Violation of OCP)","text":"<pre><code>class Shape:\n    def __init__(self, shape_type: str, dimension: float):\n        self.shape_type = shape_type\n        self.dimension = dimension\n\n    def calculate_area(self) -&gt; float:\n        if self.shape_type == \"circle\":\n            return 3.14 * (self.dimension ** 2)\n        elif self.shape_type == \"square\":\n            return self.dimension ** 2\n        else:\n            raise ValueError(\"Unknown shape type\")\n</code></pre> <p>Problems:</p> <ul> <li>Adding a new shape requires modifying the <code>calculate_area</code> method.</li> </ul>"},{"location":"guides/software_architecture/SOLID_principles/#corrected-example-applying-ocp","title":"Corrected Example (Applying OCP)","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def calculate_area(self) -&gt; float:\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    def calculate_area(self) -&gt; float:\n        return 3.14 * (self.radius ** 2)\n\nclass Square(Shape):\n    def __init__(self, side: float):\n        self.side = side\n\n    def calculate_area(self) -&gt; float:\n        return self.side ** 2\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#key-takeaway_1","title":"Key Takeaway","text":"<p>OCP ensures new functionality is added through extensions rather than modifications, making the system more maintainable.</p>"},{"location":"guides/software_architecture/SOLID_principles/#liskov-substitution-principle-lsp","title":"Liskov Substitution Principle (LSP)","text":"<p>Definition: Derived classes must be substitutable for their base classes without affecting correctness.</p>"},{"location":"guides/software_architecture/SOLID_principles/#violation-example","title":"Violation Example","text":"<pre><code>class Bird:\n    def fly(self) -&gt; str:\n        return \"I'm flying!\"\n\nclass Penguin(Bird):\n    def fly(self) -&gt; str:\n        raise NotImplementedError(\"Penguins can't fly\")\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#correct-application","title":"Correct Application","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Bird(ABC):\n    @abstractmethod\n    def move(self) -&gt; str:\n        pass\n\nclass Sparrow(Bird):\n    def move(self) -&gt; str:\n        return \"I'm flying!\"\n\nclass Penguin(Bird):\n    def move(self) -&gt; str:\n        return \"I'm swimming!\"\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#key-takeaway_2","title":"Key Takeaway","text":"<p>Subclasses should extend behavior without altering the expected behavior of the base class.</p>"},{"location":"guides/software_architecture/SOLID_principles/#interface-segregation-principle-isp","title":"Interface Segregation Principle (ISP)","text":"<p>Definition: Clients should not be forced to depend on interfaces they do not use.</p>"},{"location":"guides/software_architecture/SOLID_principles/#violation-example_1","title":"Violation Example","text":"<pre><code>class Animal:\n    def fly(self) -&gt; None:\n        pass\n\n    def swim(self) -&gt; None:\n        pass\n\nclass Bird(Animal):\n    def fly(self) -&gt; None:\n        print(\"I'm flying!\")\n\n    def swim(self) -&gt; None:\n        raise NotImplementedError(\"Birds can't swim\")\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#correct-application_1","title":"Correct Application","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Flyable(ABC):\n    @abstractmethod\n    def fly(self) -&gt; None:\n        pass\n\nclass Swimmable(ABC):\n    @abstractmethod\n    def swim(self) -&gt; None:\n        pass\n\nclass Bird(Flyable):\n    def fly(self) -&gt; None:\n        print(\"I'm flying!\")\n\nclass Fish(Swimmable):\n    def swim(self) -&gt; None:\n        print(\"I'm swimming!\")\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#key-takeaway_3","title":"Key Takeaway","text":"<p>Create specific interfaces rather than forcing classes to implement unnecessary methods.</p>"},{"location":"guides/software_architecture/SOLID_principles/#dependency-inversion-principle-dip","title":"Dependency Inversion Principle (DIP)","text":"<p>Definition:</p> <ul> <li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li> <li>Abstractions should not depend on details. Details should depend on abstractions.</li> </ul>"},{"location":"guides/software_architecture/SOLID_principles/#violation-example_2","title":"Violation Example","text":"<pre><code>class EmailSender:\n    def send_email(self, message: str) -&gt; None:\n        print(f\"Sending email: {message}\")\n\nclass NotificationService:\n    def __init__(self):\n        self.email_sender = EmailSender()\n\n    def notify(self, message: str) -&gt; None:\n        self.email_sender.send_email(message)\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#correct-application-applying-dip","title":"Correct Application (Applying DIP)","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Notifier(ABC):\n    @abstractmethod\n    def notify(self, message: str) -&gt; None:\n        pass\n\nclass EmailSender(Notifier):\n    def notify(self, message: str) -&gt; None:\n        print(f\"Sending email: {message}\")\n\nclass SMSNotifier(Notifier):\n    def notify(self, message: str) -&gt; None:\n        print(f\"Sending SMS: {message}\")\n\nclass NotificationService:\n    def __init__(self, notifier: Notifier):\n        self.notifier = notifier\n\n    def notify(self, message: str) -&gt; None:\n        self.notifier.notify(message)\n</code></pre>"},{"location":"guides/software_architecture/SOLID_principles/#key-takeaway_4","title":"Key Takeaway","text":"<p>DIP helps create modular, loosely coupled systems that are more adaptable and maintainable.</p>"},{"location":"guides/software_architecture/SOLID_principles/#final-thoughts","title":"Final Thoughts","text":"<p>By applying SOLID principles, developers create software that is flexible, maintainable, and scalable. These principles provide a strong foundation for designing robust systems that can evolve efficiently with changing business needs.</p>"},{"location":"guides/software_architecture/overview/","title":"Overview","text":""},{"location":"guides/software_architecture/overview/#software-architecture-a-foundation-for-business-agility","title":"Software Architecture: A Foundation for Business Agility","text":"<p>Software architecture is often seen as a discipline of deep technical expertise and high-level decision-making, shaping how a system is built and evolves over time. However, at its core, software architecture is not just about structure\u2014it is about enabling change. A well-designed architecture allows software to adapt to evolving business needs, scale with new projects, and remain maintainable over its lifetime.</p> <p>A software architect is not an abstract strategist disconnected from programming; rather, they are an experienced developer who continues to engage with the codebase while guiding the team. Their role is to ensure that the system\u2019s design maximizes developer productivity and supports efficient development, deployment, and maintenance.</p> <p>Contrary to common belief, the ultimate goal of architecture is not merely to make software \"work\"\u2014poorly architected systems can function, but they often become bottlenecks when businesses need to scale or pivot. Good architecture minimizes long-term costs, maximizes flexibility, and ensures that a system remains robust in the face of changing requirements. By designing systems with clear component separation and well-defined communication patterns, businesses can respond more quickly to customer needs, integrate new features efficiently, and sustain software quality over time.</p>"},{"location":"guides/unit_testing/overview/","title":"Overview","text":""},{"location":"guides/unit_testing/overview/#tbd","title":"TBD","text":""}]}